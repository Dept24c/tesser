<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>tesser.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Tesser.all 0.1.0-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tesser</span></div></div></li><li class="depth-2 branch current"><a href="tesser.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="tesser.hadoop.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>hadoop</span></div></a></li><li class="depth-3"><a href="tesser.hadoop.serialization.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>serialization</span></div></a></li><li class="depth-2 branch"><a href="tesser.math.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>math</span></div></a></li><li class="depth-2 branch"><a href="tesser.quantiles.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quantiles</span></div></a></li><li class="depth-2"><a href="tesser.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="tesser.core.html#var-any"><div class="inner"><span>any</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-assert-compiled-fold"><div class="inner"><span>assert-compiled-fold</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-compile-fold"><div class="inner"><span>compile-fold</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-count"><div class="inner"><span>count</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-deftransform"><div class="inner"><span>deftransform</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-deftransform*"><div class="inner"><span>deftransform*</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-defwraptransform"><div class="inner"><span>defwraptransform</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-empty.3F"><div class="inner"><span>empty?</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-every.3F"><div class="inner"><span>every?</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-extremum"><div class="inner"><span>extremum</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-facet"><div class="inner"><span>facet</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-filter"><div class="inner"><span>filter</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-fold"><div class="inner"><span>fold</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-frequencies"><div class="inner"><span>frequencies</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-fuse"><div class="inner"><span>fuse</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-group-by"><div class="inner"><span>group-by</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-into"><div class="inner"><span>into</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-keep"><div class="inner"><span>keep</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-map"><div class="inner"><span>map</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-mapcat"><div class="inner"><span>mapcat</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-max"><div class="inner"><span>max</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-min"><div class="inner"><span>min</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-not-every.3F"><div class="inner"><span>not-every?</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-post-combine"><div class="inner"><span>post-combine</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-range"><div class="inner"><span>range</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-reduce"><div class="inner"><span>reduce</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-remove"><div class="inner"><span>remove</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-replace"><div class="inner"><span>replace</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-set"><div class="inner"><span>set</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-some"><div class="inner"><span>some</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-take"><div class="inner"><span>take</span></div></a></li><li class="depth-1"><a href="tesser.core.html#var-tesser"><div class="inner"><span>tesser</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">tesser.core</h2><div class="doc"><div class="markdown"><p>The essential folds: <code>map</code>, <code>mapcat</code>, <code>take</code>, <code>filter</code>, <code>some</code>, <code>any?</code>, <code>into</code>, etc, plus common fold combinators.</p>
<blockquote><p>&ldquo;Now we will tesser, we will wrinkle again. Do you understand?&rdquo; &ldquo;No,&rdquo; Meg said flatly. Mrs. Whatsit sighed. &ldquo;Explanations are not easy when they are about things for which your civilization still has no words. Calvin talked about traveling at the speed of light. You understand that, little Meg?&rdquo; &ldquo;Yes,&rdquo; Meg nodded. &ldquo;That, of course, is the impractical, long way around. We have learned to take short cuts wherever possible.&rdquo; &ldquo;Sort of like in math?&rdquo; Meg asked. &ldquo;Like in math.&rdquo;</p><p>&ndash; Madeline L&rsquo;Engle, <em>A Wrinkle In Time</em>.</p>
</blockquote><p>Tesser structures partly-concurrent folds.</p><p><code>(tesser some-collections a-fold)</code> uses <code>a-fold</code> to combine some information from every element in <code>some-collections</code>: a collection of collections of inputs. Like reducers and transducers, it takes <em>fold</em> as the ultimate collection operation. Unlike transducers, Tesser folds are not sequential. They include an explicitly concurrent reduction over arbitrary partitions of the collection, and a sequential reduction over <em>those</em> reduced values, termed <em>combine</em>. Like transducers, Tesser folds can also map and filter their inputs, and perform post-processing transformation after each reduction and the combine step.</p><p>Tesser folds can be composed with the standard collection threading idioms, and evaluated against a collection of collections using <code>(tesser colls
fold)</code>.</p>
<pre><code>(-&gt;&gt; (t/map inc)
     (t/filter even?)
     (t/reduce +)
     (t/tesser [[1 2 3] [4 5 6]]))
; =&gt; 2 + 4 + 6 = 12
</code></pre></div></div><div class="public anchor" id="var-any"><h3>any</h3><div class="usage"><code>(any)</code><code>(any fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Returns any single input from the collection. O(chunks).</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L863">view source</a></div></div><div class="public anchor" id="var-assert-compiled-fold"><h3>assert-compiled-fold</h3><div class="usage"><code>(assert-compiled-fold f)</code></div><div class="doc"><div class="markdown"><p>Is this a valid compiled fold?</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L222">view source</a></div></div><div class="public anchor" id="var-compile-fold"><h3>compile-fold</h3><div class="usage"><code>(compile-fold fold)</code></div><div class="doc"><div class="markdown"><p>Compiles a fold (a sequence of transforms, each represented as a function taking the next transform) to a single map like</p>
<pre><code>{:identity (fn [] ...),
 :reducer  (fn [acc x] ...)
 ...}
</code></pre></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L234">view source</a></div></div><div class="public anchor" id="var-count"><h3>count</h3><div class="usage"><code>(count)</code><code>(count fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>How many inputs are there?</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L811">view source</a></div></div><div class="public anchor" id="var-deftransform"><h3>deftransform</h3><h4 class="type">macro</h4><div class="usage"><code>(deftransform &amp; args)</code></div><div class="doc"><div class="markdown"><p>Deftransform, assuming transforms should be appended to the end of the fold; e.g. innermost.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L359">view source</a></div></div><div class="public anchor" id="var-deftransform*"><h3>deftransform*</h3><h4 class="type">macro</h4><div class="usage"><code>(deftransform* conjoiner name docstring args &amp; body)</code></div><div class="doc"><div class="markdown"><p>We&rsquo;re trying to build functions that look like&hellip;</p>
<pre><code>(defn map
  &quot;Takes a function `f` and an optional fold. Returns a version of the
  fold which finally calls (f element) to transform each element.&quot;
  ([f]
   (map f []))
  ([f fold]
   (append fold
           (fn build [{:keys [reducer] :as downstream}]
             (assoc downstream :reducer
                    (fn reducer [acc input] (reducer acc (f input)))))))))
</code></pre><p>Which involves a fair bit of shared boilerplate: the single-arity variant of the transform, the append/prepend logic, the annealing function and its destructuring bind, etc. We&rsquo;ll wrap these up in an anaphoric macro called <code>deftransform</code>, which takes a function (e.g. <code>append</code>) to conjoin this transform with the fold. Within the body, <code>identity-</code>, <code>reducer-</code>, <code>post-reducer-</code>, <code>combiner-</code>, <code>post-combiner-</code> are all bound to the downstream transform&rsquo;s component functions, and <code>downstream</code> is bound to the downstream transform itself.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L322">view source</a></div></div><div class="public anchor" id="var-defwraptransform"><h3>defwraptransform</h3><h4 class="type">macro</h4><div class="usage"><code>(defwraptransform &amp; args)</code></div><div class="doc"><div class="markdown"><p>Like deftransform, but prepends the given transform to the beginning of the fold; e.g. outermost.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L365">view source</a></div></div><div class="public anchor" id="var-empty.3F"><h3>empty?</h3><div class="usage"><code>(empty? &amp; [f])</code></div><div class="doc"><div class="markdown"><p>Returns true iff no inputs arrive; false otherwise. For instance:</p>
<pre><code>(t/tesser [[]] (t/empty?))
; =&gt; true
</code></pre></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L875">view source</a></div></div><div class="public anchor" id="var-every.3F"><h3>every?</h3><div class="usage"><code>(every? pred &amp; [f])</code></div><div class="doc"><div class="markdown"><p>True iff every input satisfies the given predicate, false otherwise. For instance:</p>
<pre><code>(t/tesser [[1 3 5]] (t/every? odd?))
; =&gt; true
</code></pre></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L887">view source</a></div></div><div class="public anchor" id="var-extremum"><h3>extremum</h3><div class="usage"><code>(extremum compare)</code><code>(extremum compare fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Finds the largest element using a comparison function (default: <code>compare</code>).</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L913">view source</a></div></div><div class="public anchor" id="var-facet"><h3>facet</h3><div class="usage"><code>(facet)</code><code>(facet fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Your inputs are maps, and you want to apply a fold to each value independently. Facet generalizes a fold over a single value to operate on maps of keys to those values, returning a map of keys to the results of the fold over all values for that key. Each key gets an independent instance of the fold.</p><p>For instance, say you have inputs like</p>
<pre><code>{:x 1, :y 2}
{}
{:y 3, :z 4}
</code></pre><p>Then the fold</p>
<pre><code>(-&gt;&gt; (facet)
     (mean))
</code></pre><p>returns a map for each key&rsquo;s mean value:</p>
<pre><code>{:x 1, :y 2, :z 4}
</code></pre></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L711">view source</a></div></div><div class="public anchor" id="var-filter"><h3>filter</h3><div class="usage"><code>(filter pred)</code><code>(filter pred fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Takes a predicate function <code>pred</code> and an optional fold. Returns a version of the fold which only passes on inputs to subsequent transforms when (pred input) is truthy.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L411">view source</a></div></div><div class="public anchor" id="var-fold"><h3>fold</h3><div class="usage"><code>(fold combinef reducef)</code><code>(fold combinef reducef fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Like <code>reducers/fold</code>, turns a combiner and a reducer function into a fold. Unlike <code>reducers/fold</code>, this <code>fold</code> doesn&rsquo;t take a collection: it just returns a fold which can be applied to a collection via <code>tesser</code>. Why? You might want to compose the fold with something else using <code>fuse</code>, map it with <code>post-combine</code>, etc etc.</p><p>Follows the clojure reducers and transducers conventions for arities:</p>
<ul>
  <li><code>(f)</code> returns a new identity element for the reduce/combine phase</li>
  <li><code>(f acc input)</code> folds elements in the reduce/combine phases.</li>
  <li><code>(f acc)</code> post-reduces/post-combines, unless <code>(f acc)</code> throws  clojure.lang.ArityException, in which case we return <code>acc</code> directly.</li>
</ul><p><code>tesser.core/fold</code> should be a straightforward replacement for <code>clojure.core.reducers/fold</code>, except you&rsquo;ll do the chunking yourself:</p>
<pre><code>(-&gt;&gt; (t/fold set/union                ; combine via set union
             (fn ([] #{})             ; identity is empty set
                 ([s x] (conj s x)))) ; conj into set
     (t/tesser [[1 2 3] [4 5 6]]))
; =&gt; #{1 4 6 3 2 5}
</code></pre></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L566">view source</a></div></div><div class="public anchor" id="var-frequencies"><h3>frequencies</h3><div class="usage"><code>(frequencies)</code><code>(frequencies fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Like clojure.core/frequencies, returns a map of inputs to the number of times those inputs appeared in the collection.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L831">view source</a></div></div><div class="public anchor" id="var-fuse"><h3>fuse</h3><div class="usage"><code>(fuse fold-map)</code><code>(fuse fold-map fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>You&rsquo;ve got several folds, and want to execute them in one pass. Fuse is the function for you! It takes a map from keys to folds, like</p>
<pre><code>(-&gt;&gt; (map parse-person)
     (fuse {:age-range    (-&gt;&gt; (map :age) (range))
            :colors-prefs (-&gt;&gt; (map :favorite-color) (frequencies))})
     (tesser people))
</code></pre><p>And returns a map from those same keys to the results of the corresponding folds:</p>
<pre><code>{:age-range   [0 74],
 :color-prefs {:red        120
               :blue       312
               :watermelon 1953
               :imhotep    1}}
</code></pre><p>Note that this fold only invokes <code>parse-person</code> once for each record, and completes in a single pass. If we ran the age and color folds independently, it&rsquo;d take two passes over the dataset&ndash;and require parsing every person <em>twice</em>.</p><p>Fuse and facet both return maps, but generalize over different axes. Fuse applies a fixed set of <em>independent</em> folds over the <em>same</em> inputs, where facet applies the <em>same</em> fold to a dynamic set of keys taken from the inputs.</p><p>Note that fuse compiles the folds you pass to it, so you need to build them completely <em>before</em> fusing. The fold <code>fuse</code> returns can happily be combined with other transformations at its level, but its internal folds are sealed and opaque.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L751">view source</a></div></div><div class="public anchor" id="var-group-by"><h3>group-by</h3><div class="usage"><code>(group-by category-fn)</code><code>(group-by category-fn fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Every input belongs to exactly one category, and you&rsquo;d like to apply a fold to each category separately.</p><p>Group-by takes a function that returns a category for every element, and returns a map of those categories to the results of the downstream fold applied to the inputs in that category.</p><p>For instance, say we have a collection of particles of various types, and want to find the highest mass of each particle type:</p>
<pre><code>(-&gt;&gt; (t/group-by :type)
     (t/map :mass)
     (t/max)
     (t/tesser [[{:name :electron, :type :lepton, :mass 0.51}
                 {:name :muon,     :type :lepton, :mass 105.65}
                 {:name :up,       :type :quark,  :mass 1.5}
                 {:name :down,     :type :quark,  :mass 3.5}]]))
; =&gt; {:lepton 105.65, :quark 3.5}
</code></pre></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L677">view source</a></div></div><div class="public anchor" id="var-into"><h3>into</h3><div class="usage"><code>(into coll)</code><code>(into coll fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Adds all inputs to the given collection using conj. Ordering of elements from distinct chunks is undefined.</p><p>TODO: distinct identities for reducer and combiner would allow us to conj into (empty coll) in reducer, then start with coll for combine. Doesn&rsquo;t really save much for injective collections, but for sets/maps could be more efficient.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L638">view source</a></div></div><div class="public anchor" id="var-keep"><h3>keep</h3><div class="usage"><code>(keep f)</code><code>(keep f fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Takes a function <code>f</code> and an optional fold. Returns a version of the fold which finally calls (f input) to transform each element, and passes it on to subsequent transforms only when the result of (f input) is truthy.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L401">view source</a></div></div><div class="public anchor" id="var-map"><h3>map</h3><div class="usage"><code>(map f)</code><code>(map f fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Takes a function <code>f</code> and an optional fold. Returns a version of the fold which finally calls (f input) to transform each element.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L373">view source</a></div></div><div class="public anchor" id="var-mapcat"><h3>mapcat</h3><div class="usage"><code>(mapcat f)</code><code>(mapcat f fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Takes a function <code>f</code> and an optional fold. Returns a version of the fold which finally calls (f input) to transform each element. (f input) should return a <em>sequence</em> of inputs which will be fed to the downstream transform independently.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L392">view source</a></div></div><div class="public anchor" id="var-max"><h3>max</h3><div class="usage"><code>(max &amp; [f])</code></div><div class="doc"><div class="markdown"><p>Finds the largest value using <code>compare</code>.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L933">view source</a></div></div><div class="public anchor" id="var-min"><h3>min</h3><div class="usage"><code>(min &amp; [f])</code></div><div class="doc"><div class="markdown"><p>Finds the smallest value using <code>compare</code>.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L928">view source</a></div></div><div class="public anchor" id="var-not-every.3F"><h3>not-every?</h3><div class="usage"><code>(not-every? pred &amp; [f])</code></div><div class="doc"><div class="markdown"><p>True if there exists an input which does <em>not</em> satisfy the given predicate. For instance:</p>
<pre><code>(t/tesser [[1 3 5] [6]] (t/not-every? odd?))
; =&gt; true
</code></pre></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L898">view source</a></div></div><div class="public anchor" id="var-post-combine"><h3>post-combine</h3><div class="usage"><code>(post-combine f)</code><code>(post-combine f fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Transforms the output of a fold by applying a function to it.</p><p>For instance, to find the square root of the mean of a sequence of numbers, try</p>
<pre><code>(-&gt;&gt; (t/mean) (t/post-combine sqrt) (t/tesser nums))
</code></pre><p>For clarity in -&gt;&gt; composition, post-combine composes in the opposite direction from map, filter, etc. It <em>prepends</em> a transform to the given fold instead of <em>appending</em> one. This means post-combines take effect in the same order you&rsquo;d expect from -&gt;&gt; with normal function calls:</p>
<pre><code>(-&gt;&gt; (t/mean)                 (-&gt;&gt; (mean nums)
     (t/post-combine sqrt)         (sqrt)
     (t/post-combine inc))         (inc))
</code></pre></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L654">view source</a></div></div><div class="public anchor" id="var-range"><h3>range</h3><div class="usage"><code>(range &amp; [f])</code></div><div class="doc"><div class="markdown"><p>Returns a pair of <code>[smallest largest]</code> inputs, using <code>compare</code>.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L938">view source</a></div></div><div class="public anchor" id="var-reduce"><h3>reduce</h3><div class="usage"><code>(reduce f init)</code><code>(reduce f init fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>A fold that uses the same function for the reduce and combine phases. Unlike normal Clojure reduce, this reduce doesn&rsquo;t take a collection: it just returns a fold which can be applied to a collection via <code>tesser</code>. Why? You might want to compose the reduction with something else using <code>fuse</code>, map it with <code>post-combine</code>, etc etc.</p><p>Follows the clojure reducers and transducers conventions for arities:</p>
<ul>
  <li><code>(constantly init)</code> is used to generate identity elements.</li>
  <li><code>(f acc input)</code> folds elements in the reduce and combine phases.</li>
  <li><code>(f acc)</code> post-reduces and post-combines, unless <code>(f acc)</code> throws  clojure.lang.ArityException, in which case we return <code>acc</code> directly.</li>
</ul><p>This means you can use probably <code>(reduce f init)</code> as a phase anywhere <code>f</code> is associative and commutative, and where <code>init</code> is immutable.</p>
<pre><code>(-&gt;&gt; (t/map inc)
     (t/reduce + 0)
     (t/tesser [[1 2 3] [4 5 6]]))
; =&gt; 27
</code></pre><p>Due to technical limitations Tesser can&rsquo;t distinguish between</p>
<pre><code>(reduce + upstream-fold)
</code></pre><p>where we&rsquo;re transforming an uncompiled fold by adding a reduce phase, and</p>
<pre><code>(reduce + 0)
</code></pre><p>where we&rsquo;re defining a new phase out of thin air with 0 as the initial value. Consequently, we <em>always</em> interpret the second argument as an initial value. We <em>don&rsquo;t</em> provide an equivalent for <code>(reduce +)</code> yet. Someday. Use <code>(fold +
+)</code> or <code>(reduce + (+))</code> instead.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L596">view source</a></div></div><div class="public anchor" id="var-remove"><h3>remove</h3><div class="usage"><code>(remove pred)</code><code>(remove pred fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Takes a predicate function <code>pred</code> and an optional fold. Returns a version of the fold which only passes on inputs to subsequent transforms when (pred input) is nil or false.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L421">view source</a></div></div><div class="public anchor" id="var-replace"><h3>replace</h3><div class="usage"><code>(replace m &amp; [f])</code></div><div class="doc"><div class="markdown"><p>Given a map of replacement pairs, maps any inputs which are keys in the map to their corresponding values. Leaves unrecognized inputs alone.</p>
<pre><code>(-&gt;&gt; (t/replace {:x false})
     (t/into [])
     (t/tesser [[:x :y]]))
; =&gt; [false :y]
</code></pre></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L380">view source</a></div></div><div class="public anchor" id="var-set"><h3>set</h3><div class="usage"><code>(set)</code><code>(set fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>A hash-set of distinct inputs.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L821">view source</a></div></div><div class="public anchor" id="var-some"><h3>some</h3><div class="usage"><code>(some pred)</code><code>(some pred fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Returns the first logical true value of (pred input). If no such satisfying input exists, returns nil.</p><p>This is potentially <em>less</em> efficient than clojure.core/some because each reducer has to find a matching element independently, and they have no way to communicate when one has found an element. In the worst-case scenario, requires N calls to <code>pred</code>. However, unlike clojure.core/some, this version is parallelizable&ndash;which can make it more efficient when the element is rare.</p>
<pre><code>(t/tesser [[1 2 3] [4 5 6]] (t/some #{1 2}))
; =&gt; 1
</code></pre></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L843">view source</a></div></div><div class="public anchor" id="var-take"><h3>take</h3><div class="usage"><code>(take n)</code><code>(take n fold__1874__auto__)</code></div><div class="doc"><div class="markdown"><p>Like clojure.core/take, limits the number of inputs passed to the downstream transformer to exactly n, or if fewer than n inputs exist in total, all inputs.</p><p>Space complexity note: take&rsquo;s reducers produce log2(chunk-size) reduced values per chunk, ranging from 1 to chunk-size/2 inputs, rather than a single reduced value for each chunk. See the source for <em>why</em> this is the case.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L431">view source</a></div></div><div class="public anchor" id="var-tesser"><h3>tesser</h3><div class="usage"><code>(tesser seqs fold)</code></div><div class="doc"><div class="markdown"><p>Compiles a fold and applies it to a sequence of sequences of inputs. Runs num-procs threads for the parallel (reducer) portion of the fold. Reducers take turns combining their results, which prevents unbounded memory consumption by the reduce phase.</p></div></div><div class="src-link"><a href="http://github.com/aphyr/tesser/blob/master/master/../core/src/tesser/core.clj#L248">view source</a></div></div></div></body></html>